## 问题描述

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
```
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```

## 思路
先来想一下，如果逆序的话，一定是从后向前递增的，这时候直接重新排列就可以了

但是如果非逆序的话，一定会出现某一位比前一位大的情况；

我们应该让这个前一位加上去，既这前一位的数字必须是后面所有数字中刚好比他大的（不一定是最大的）。所以我们可以对后面的数字排序，找到第一个比他大的

例如：
1,4,5,3,2->1,5,2,3,4

是找到4,5====以5为基点，后面所有的重新排序，找到第一个比4大的数交换位置

```java
// #源于离散数学及其应用的算法：（以3 4 5 2 1 为例）
// #从后往前寻找第一次出现的正序对：（找到 4,5）
// #之后因为从5 开始都是逆序，所以把他们反转就是正序：3 4 1 2 5
// #之后4 的位置应该是：在它之后的，比他大的最小值（5）
// #交换这两个值：得到 3 5 1 2 4
// # 对于初始即为逆序的序列，将在反转步骤直接完成
class Solution {
    public void nextPermutation(int[] nums) {
        int flag = 0;
        for(int i = nums.length-1;i > 0;i--){
            if(nums[i-1] < nums[i]){
                Arrays.sort(nums,i,nums.length);
                for(int j = i;j < nums.length;j++){
                    if(nums[i-1] < nums[j]){
                        int tmp = nums[j];
                        nums[j] = nums[i-1];
                        nums[i-1] = tmp;
                        break;
                    }
                }
                flag = 1;
                break;
            }
        }
        if(flag==0)Arrays.sort(nums);
    }
}
```

